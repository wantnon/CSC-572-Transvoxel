// 供 AttribWrangle 使用：把原始脚本包进函数，避免被当作“全局作用域脚本”解析时报错
// 用法（写在 Wrangle 的 VEXpression 里）：
//   #include "boundaryCellVEX.txt"
//   boundaryCell_main();

void boundaryCell_main()
{
// VEX Code for Detail Wrangle - 生成 Boundary Cell 点阵（补一圈版本）
// Input 0: trunk0 体素点云（来自 chunkVEX.txt）
// Input 1: trunk1 体素点云（来自 chunkVEX.txt）
// Input 2: fog VDB volume（用于实时采样密度值，可选）
//
// LOD 过渡处理：
// - lodLevel0: trunk0 的 LOD 级别
// - lodLevel1: trunk1 的 LOD 级别
//
// 功能：
// 生成低分辨率边界 regular cell，用于补齐 transition cell 与低分辨率区域之间的空隙
// 对应 pointsVEX.txt 中的"低分辨率边界 regular cell"
//
// 与 boundaryCellVEX.txt 的差异（补一圈）：
// - 原版在边界平面上两维的遍历是：for (v = voxel_scale; v < voxel_res - 1; v += voxel_scale)
//   在 voxel_res=32, voxel_scale=2 时得到 2,4,...,30 => 15 个（15x15）
// - 本版本改为：for (v = voxel_scale; v <= voxel_res; v += voxel_scale)
//   在 voxel_res=32, voxel_scale=2 时得到 2,4,...,32 => 16 个（16x16），即补齐外侧一圈
//
// 说明：
// - 这里的 voxel_x/y/z 被当作“upper corner（右上前角）”的网格坐标（与 pointsVEX/ formerVersionVEX 语义一致）
// - 允许取到 voxel_res（例如 32），意味着会生成覆盖到 chunk 边界（16m 处）的那一圈 cell
// - 若你的 VDB/体素场在边界处没有 padding，可能会暴露边/角 case（重复/缺口/越界采样），这属于正常现象
//
// --- 参数 ---
int lod_level_0 = chi("lodLevel0");  // trunk0 的 LOD 级别
int lod_level_1 = chi("lodLevel1");  // trunk1 的 LOD 级别

lod_level_0 = max(lod_level_0, 0);
lod_level_1 = max(lod_level_1, 0);

// 重要：当两侧 LOD 相同（例如 1 vs 1）时，不应生成 boundary cell
// boundary cell 只用于“transition cell 与低分辨率区域之间”的补齐
if (lod_level_0 == lod_level_1) {
    int npt = npoints(0);
    for (int i = npt - 1; i >= 0; --i) {
        removepoint(0, i);
    }
    return;
}

// 从 trunk0 和 trunk1 获取基础信息
vector min_bound_0, min_bound_1;
vector chunk_origin_0, chunk_origin_1;
vector base_voxel_size;
int base_voxel_scale;
float chunk_size;
int voxel_res = 32;  // 基础分辨率：32x32x32（默认值）
int chunk_x_0 = 0, chunk_y_0 = 0, chunk_z_0 = 0;
int chunk_x_1 = 0, chunk_y_1 = 0, chunk_z_1 = 0;

// 从 trunk0 读取基础信息
if (npoints(0) > 0 && hasattrib(0, "point", "chunk_origin")) {
    int first_pt = 0;
    min_bound_0 = point(0, "min_bound", first_pt);
    chunk_origin_0 = point(0, "chunk_origin", first_pt);
    base_voxel_size = point(0, "voxel_size", first_pt);
    base_voxel_scale = point(0, "voxel_scale", first_pt);
    chunk_size = point(0, "chunk_size", first_pt);
    if (hasattrib(0, "point", "chunk_x")) {
        chunk_x_0 = point(0, "chunk_x", first_pt);
        chunk_y_0 = point(0, "chunk_y", first_pt);
        chunk_z_0 = point(0, "chunk_z", first_pt);
    }
    if (chunk_size > 0 && base_voxel_size.x > 0) {
        voxel_res = (int)(chunk_size / base_voxel_size.x);
    }
} else {
    min_bound_0 = set(0, 0, 0);
    chunk_origin_0 = set(0, 0, 0);
    base_voxel_size = set(0.5, 0.5, 0.5);
    base_voxel_scale = 1;
    chunk_size = 16.0;
    voxel_res = 32;
}

// 从 trunk1 读取基础信息
if (npoints(1) > 0 && hasattrib(1, "point", "chunk_origin")) {
    int first_pt = 0;
    min_bound_1 = point(1, "min_bound", first_pt);
    chunk_origin_1 = point(1, "chunk_origin", first_pt);
    if (hasattrib(1, "point", "chunk_x")) {
        chunk_x_1 = point(1, "chunk_x", first_pt);
        chunk_y_1 = point(1, "chunk_y", first_pt);
        chunk_z_1 = point(1, "chunk_z", first_pt);
    }
} else {
    min_bound_1 = set(0, 0, 0);
    chunk_origin_1 = set(0, 0, 0);
}

// 确定使用哪个 trunk 的坐标系（低分辨率侧）
// boundary cell 应该在低分辨率侧生成，与 transition cell 在同一层
vector min_bound;
vector chunk_origin;
int use_trunk1_coord = 0;
int high_res_trunk = 0;  // 0=trunk0, 1=trunk1

if (lod_level_1 >= lod_level_0) {
    // trunk1 是低分辨率侧
    min_bound = min_bound_1;
    chunk_origin = chunk_origin_1;
    use_trunk1_coord = 1;
    high_res_trunk = 0;  // trunk0 是高分辨率侧
} else {
    // trunk0 是低分辨率侧
    min_bound = min_bound_0;
    chunk_origin = chunk_origin_0;
    use_trunk1_coord = 0;
    high_res_trunk = 1;  // trunk1 是高分辨率侧
}

// 计算 LOD 缩放
int lod_scale_0 = (int)pow(2.0, lod_level_0);
int lod_scale_1 = (int)pow(2.0, lod_level_1);

// 确定低分辨率侧的缩放
int lod_scale_lowres;
if (lod_level_1 >= lod_level_0) {
    lod_scale_lowres = lod_scale_1;
} else {
    lod_scale_lowres = lod_scale_0;
}

// 计算实际的体素缩放（使用低分辨率侧的缩放）
int voxel_scale = base_voxel_scale * lod_scale_lowres;
vector voxel_size = base_voxel_size;  // 基础体素大小，不乘以 LOD 缩放

// 确定边界方向和位置（与 transCellVEX.txt 一致）
int chunk_diff_x = chunk_x_1 - chunk_x_0;
int chunk_diff_y = chunk_y_1 - chunk_y_0;
int chunk_diff_z = chunk_z_1 - chunk_z_0;

int abs_chunk_x = abs(chunk_diff_x);
int abs_chunk_y = abs(chunk_diff_y);
int abs_chunk_z = abs(chunk_diff_z);

int boundary_axis = 2;  // 默认 Z 方向 (0=X, 1=Y, 2=Z)
int lod_boundary;

if (abs_chunk_x >= abs_chunk_y && abs_chunk_x >= abs_chunk_z) {
    // X 方向边界
    boundary_axis = 0;
    int chunk_diff;
    if (use_trunk1_coord) {
        chunk_diff = chunk_x_0 - chunk_x_1;
    } else {
        chunk_diff = chunk_x_1 - chunk_x_0;
    }

    if (chunk_diff > 0) {
        lod_boundary = voxel_res - 1;
    } else if (chunk_diff < 0) {
        // 高分辨率 trunk 在负方向，边界在第一层
        lod_boundary = voxel_scale;
    } else {
        lod_boundary = voxel_res / 2;
    }
} else if (abs_chunk_y >= abs_chunk_x && abs_chunk_y >= abs_chunk_z) {
    // Y 方向边界
    boundary_axis = 1;
    int chunk_diff;
    if (use_trunk1_coord) {
        chunk_diff = chunk_y_0 - chunk_y_1;
    } else {
        chunk_diff = chunk_y_1 - chunk_y_0;
    }

    if (chunk_diff > 0) {
        lod_boundary = voxel_res - 1;
    } else if (chunk_diff < 0) {
        lod_boundary = voxel_scale;
    } else {
        lod_boundary = voxel_res / 2;
    }
} else {
    // Z 方向边界（默认）
    boundary_axis = 2;
    int chunk_diff;
    if (use_trunk1_coord) {
        chunk_diff = chunk_z_0 - chunk_z_1;
    } else {
        chunk_diff = chunk_z_1 - chunk_z_0;
    }

    if (chunk_diff > 0) {
        lod_boundary = voxel_res - 1;
    } else if (chunk_diff < 0) {
        lod_boundary = voxel_scale;
    } else {
        lod_boundary = voxel_res / 2;
    }
}

// --- 清除输入点 ---
int num_points = npoints(0);
for (int i = num_points - 1; i >= 0; i--) {
    removepoint(0, i);
}

// --- 生成 boundary cell 点阵（补一圈）---
// boundary cell 与 transition cell 在同一层（lod_boundary），使用相同的遍历方式
// 注意：这里将“另外两维”的范围补到 <= voxel_res
int x, y, z;

if (boundary_axis == 0) {
    // X 方向边界：固定 x = lod_boundary，循环 y 和 z
    x = lod_boundary;
    for (int z = voxel_scale; z <= voxel_res; z += voxel_scale) {
        for (int y = voxel_scale; y <= voxel_res; y += voxel_scale) {
            // 计算 boundary cell 中心位置（与 pointsVEX.txt 一致）
            vector voxel_center = min_bound + (set(x, y, z) - set(voxel_scale, voxel_scale, voxel_scale) * 0.5) * voxel_size;

            int pt = addpoint(0, voxel_center);

            // 存储体素的网格索引
            setpointattrib(0, "voxel_x", pt, x);
            setpointattrib(0, "voxel_y", pt, y);
            setpointattrib(0, "voxel_z", pt, z);

            // 存储体素大小和边界信息
            setpointattrib(0, "voxel_size", pt, voxel_size);
            setpointattrib(0, "min_bound", pt, min_bound);
            setpointattrib(0, "voxel_scale", pt, voxel_scale);
            setpointattrib(0, "chunk_origin", pt, chunk_origin);

            // 存储 LOD 信息
            setpointattrib(0, "lod_level_0", pt, lod_level_0);
            setpointattrib(0, "lod_level_1", pt, lod_level_1);
            setpointattrib(0, "lod_scale_0", pt, lod_scale_0);
            setpointattrib(0, "lod_scale_1", pt, lod_scale_1);
            setpointattrib(0, "base_voxel_size", pt, base_voxel_size);
            setpointattrib(0, "base_voxel_scale", pt, base_voxel_scale);

            // 标记为 boundary cell（低分辨率边界 regular cell）
            setpointattrib(0, "is_boundary_lowres", pt, 1);
            setpointattrib(0, "boundary_axis", pt, boundary_axis);
            // 补一圈标记：用于下游在边/角处做保护（避免 half-thickness 偏移把点推到 chunk 外）
            int is_makeup_ring = (y == voxel_res) || (z == voxel_res);
            setpointattrib(0, "is_makeup_ring", pt, is_makeup_ring);
            // 传递 chunk 尺寸/分辨率，便于下游做边界 clamp
            setpointattrib(0, "chunk_size", pt, chunk_size);
            setpointattrib(0, "voxel_res", pt, voxel_res);

            // 计算体素中心的密度值用于颜色可视化
            float center_density = 0.0;
            if (hasattrib(2, "volume", "density")) {
                center_density = volumesample(2, "density", voxel_center);
            }
            vector color = set(center_density, center_density, center_density);
            setpointattrib(0, "Cd", pt, color);
        }
    }
} else if (boundary_axis == 1) {
    // Y 方向边界：固定 y = lod_boundary，循环 x 和 z
    y = lod_boundary;
    for (int z = voxel_scale; z <= voxel_res; z += voxel_scale) {
        for (int x = voxel_scale; x <= voxel_res; x += voxel_scale) {
            vector voxel_center = min_bound + (set(x, y, z) - set(voxel_scale, voxel_scale, voxel_scale) * 0.5) * voxel_size;

            int pt = addpoint(0, voxel_center);

            setpointattrib(0, "voxel_x", pt, x);
            setpointattrib(0, "voxel_y", pt, y);
            setpointattrib(0, "voxel_z", pt, z);

            setpointattrib(0, "voxel_size", pt, voxel_size);
            setpointattrib(0, "min_bound", pt, min_bound);
            setpointattrib(0, "voxel_scale", pt, voxel_scale);
            setpointattrib(0, "chunk_origin", pt, chunk_origin);

            setpointattrib(0, "lod_level_0", pt, lod_level_0);
            setpointattrib(0, "lod_level_1", pt, lod_level_1);
            setpointattrib(0, "lod_scale_0", pt, lod_scale_0);
            setpointattrib(0, "lod_scale_1", pt, lod_scale_1);
            setpointattrib(0, "base_voxel_size", pt, base_voxel_size);
            setpointattrib(0, "base_voxel_scale", pt, base_voxel_scale);

            setpointattrib(0, "is_boundary_lowres", pt, 1);
            setpointattrib(0, "boundary_axis", pt, boundary_axis);
            int is_makeup_ring = (x == voxel_res) || (z == voxel_res);
            setpointattrib(0, "is_makeup_ring", pt, is_makeup_ring);
            setpointattrib(0, "chunk_size", pt, chunk_size);
            setpointattrib(0, "voxel_res", pt, voxel_res);

            float center_density = 0.0;
            if (hasattrib(2, "volume", "density")) {
                center_density = volumesample(2, "density", voxel_center);
            }
            vector color = set(center_density, center_density, center_density);
            setpointattrib(0, "Cd", pt, color);
        }
    }
} else {
    // Z 方向边界（默认）：固定 z = lod_boundary，循环 x 和 y
    z = lod_boundary;
    for (int y = voxel_scale; y <= voxel_res; y += voxel_scale) {
        for (int x = voxel_scale; x <= voxel_res; x += voxel_scale) {
            vector voxel_center = min_bound + (set(x, y, z) - set(voxel_scale, voxel_scale, voxel_scale) * 0.5) * voxel_size;

            int pt = addpoint(0, voxel_center);

            setpointattrib(0, "voxel_x", pt, x);
            setpointattrib(0, "voxel_y", pt, y);
            setpointattrib(0, "voxel_z", pt, z);

            setpointattrib(0, "voxel_size", pt, voxel_size);
            setpointattrib(0, "min_bound", pt, min_bound);
            setpointattrib(0, "voxel_scale", pt, voxel_scale);
            setpointattrib(0, "chunk_origin", pt, chunk_origin);

            setpointattrib(0, "lod_level_0", pt, lod_level_0);
            setpointattrib(0, "lod_level_1", pt, lod_level_1);
            setpointattrib(0, "lod_scale_0", pt, lod_scale_0);
            setpointattrib(0, "lod_scale_1", pt, lod_scale_1);
            setpointattrib(0, "base_voxel_size", pt, base_voxel_size);
            setpointattrib(0, "base_voxel_scale", pt, base_voxel_scale);

            setpointattrib(0, "is_boundary_lowres", pt, 1);
            setpointattrib(0, "boundary_axis", pt, boundary_axis);
            int is_makeup_ring = (x == voxel_res) || (y == voxel_res);
            setpointattrib(0, "is_makeup_ring", pt, is_makeup_ring);
            setpointattrib(0, "chunk_size", pt, chunk_size);
            setpointattrib(0, "voxel_res", pt, voxel_res);

            float center_density = 0.0;
            if (hasattrib(2, "volume", "density")) {
                center_density = volumesample(2, "density", voxel_center);
            }
            vector color = set(center_density, center_density, center_density);
            setpointattrib(0, "Cd", pt, color);
        }
    }
}

}


