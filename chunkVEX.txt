// VEX Code for Detail Wrangle - 根据 chunkID 生成 chunk 体素点阵
// 
// 重要：此代码必须在 Detail Wrangle 节点中使用！
// 
// 功能说明：
// - 根据输入的 chunkID (x, y, z) 创建 chunk
// - 每个 chunk 大小：16m x 16m x 16m
// - 始终生成最高分辨率：32x32x32 个体素，每个体素 0.5m（32,768 个点）
// - LOD 处理将在 marchCubeVEX 中进行，而不是在 chunkVEX 中
// - 每个体素格以位于体素中心的一个 point 表示
// - 按照 MarchingCubesCS.usf 的方式：不存储任何角点数据
//   角点位置和密度值将在后续节点中从体素索引实时计算和采样
//
// 使用方法：
// 1. 在 Houdini 中创建一个 Detail Wrangle 节点
// 2. 将此代码复制到 VEXpression 中
// 3. 在参数面板设置 chunk_x, chunk_y, chunk_z 值
//
// 注意：
// - 如果看不到点，检查视图范围，点会在原点 (0,0,0) 附近
// - 可以通过修改 chunkID 来移动 chunk 的位置
// - 查看控制台输出确认代码是否执行

// --- 参数设置 ---
// Chunk 尺寸（米）
float chunk_size = 16.0;  // 每个 chunk 的尺寸（16m x 16m x 16m）

// 体素分辨率（固定为最高分辨率）
int voxel_res = 32;  // 固定分辨率：32x32x32

// 体素大小（米）
float voxel_size = chunk_size / voxel_res;  // 16.0 / 32 = 0.5m

// --- 获取参数 ---
// 从通道参数获取整数
// 注意：需要在 Houdini 节点的参数面板中添加整数参数 "chunk_x", "chunk_y", "chunk_z"
int chunk_x = chi("chunk_x");
int chunk_y = chi("chunk_y");
int chunk_z = chi("chunk_z");

// --- 计算 chunk 的世界坐标起始位置 ---
// Chunk 的起始位置 = chunkID * chunk_size
vector chunk_origin = set(chunk_x * chunk_size, chunk_y * chunk_size, chunk_z * chunk_size);
// min_bound 用于与 pointsVEX 保持一致（对于 chunk 来说，min_bound = chunk_origin）
vector min_bound = chunk_origin;

// voxel_scale 固定为 1（最高分辨率，LOD 处理在 marchCubeVEX 中进行）
int voxel_scale = 1;

// --- 生成体素点阵 ---
// 遍历 32x32x32 个体素格，每个体素格在中心位置创建一个点
for (int z = 0; z < voxel_res; z++) {
    for (int y = 0; y < voxel_res; y++) {
        for (int x = 0; x < voxel_res; x++) {
            // 计算体素中心的位置（世界坐标）
            // 体素中心位置 = chunk_origin + (voxel_index + 0.5) * voxel_size
            vector local_pos = set((x + 0.5) * voxel_size, 
                                   (y + 0.5) * voxel_size, 
                                   (z + 0.5) * voxel_size);
            vector voxel_center = chunk_origin + local_pos;
            
            // 按照 MarchingCubesCS.usf 的方式：不存储任何角点数据
            // 角点位置和密度值将在后续节点中从体素索引实时计算和采样
            
            // 创建点，位置在体素中心
            int pt = addpoint(0, voxel_center);
            
            // 存储体素的网格索引（与 pointsVEX 一致）
            setpointattrib(0, "voxel_x", pt, x);
            setpointattrib(0, "voxel_y", pt, y);
            setpointattrib(0, "voxel_z", pt, z);
            
            // 存储体素大小和边界信息（与 pointsVEX 一致）
            setpointattrib(0, "voxel_size", pt, voxel_size);
            setpointattrib(0, "min_bound", pt, min_bound);
            setpointattrib(0, "voxel_scale", pt, voxel_scale);
            
            // 按照 MarchingCubesCS.usf 的方式：不存储任何角点数据
            // 角点位置和密度值将在后续节点中从体素索引实时计算和采样
            
            // 存储 chunk 信息（额外属性）
            setpointattrib(0, "chunk_x", pt, chunk_x);
            setpointattrib(0, "chunk_y", pt, chunk_y);
            setpointattrib(0, "chunk_z", pt, chunk_z);
            setpointattrib(0, "chunk_size", pt, chunk_size);
            setpointattrib(0, "chunk_origin", pt, chunk_origin);
            
            // 计算体素中心的密度值用于颜色可视化（从 input 1 采样，如果连接了 VDB）
            float center_density = 0.0;
            if (hasattrib(0, "volume", "density")) {
                center_density = volumesample(1, "density", voxel_center);
            }
            vector color = set(center_density, center_density, center_density);
            setpointattrib(0, "Cd", pt, color);
        }
    }
}
