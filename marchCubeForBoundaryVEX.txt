// VEX Code for Point Wrangle - Boundary Cell 三角化
// Input 0: boundary cell 点云（来自 boundaryCellVEX.txt）
// Input 1: 查找表数据（Detail Wrangle 节点）
// Input 2: fog VDB volume（用于实时采样密度值）
//
// 功能：
// 专门处理 boundary cell 的三角化
// boundary cell 是低分辨率边界 regular cell，用于补齐 transition cell 与低分辨率区域之间的空隙
// 需要对特定角点做半厚度偏移，使其变成半厚度

// 从 input1 读取查找表数据（detail 属性）
int regularCellClass[] = detail(1, "regularCellClass");
int regularCellData[] = detail(1, "regularCellData");
int regularVertexData[] = detail(1, "regularVertexData");

// 检查查找表是否存在（如果数组为空，可能查找表未连接）
if (len(regularCellClass) == 0 || len(regularCellData) == 0 || len(regularVertexData) == 0) {
    @group_del = 1;  // 查找表未连接或为空
    return;
}

// 线性插值计算交点（与computeTrianglesForVoxel中的插值方式完全一致）
vector VertexLerp(float isolevel; vector p1, p2; float val1, val2) {
    if (abs(isolevel - val1) < 0.00001) return p1;
    if (abs(isolevel - val2) < 0.00001) return p2;
    if (abs(val1 - val2) < 0.00001) return p1;

    float t;
    if (abs(isolevel) < 0.00001) {
        t = val2 / (val2 - val1);
        return p1 * t + p2 * (1.0 - t);
    } else {
        t = (isolevel - val1) / (val2 - val1);
        return lerp(p1, p2, t);
    }
}

// 将“偏移”限制在 AABB 内：不直接 clamp 点位（会造成折叠/自相交），而是按比例缩小 offset
vector ApplyOffsetClamped(vector p; vector offset; vector bmin; vector bmax) {
    float t = 1.0;
    // X
    if (abs(offset.x) > 1e-12) {
        if (offset.x > 0) t = min(t, (bmax.x - p.x) / offset.x);
        else              t = min(t, (bmin.x - p.x) / offset.x);
    }
    // Y
    if (abs(offset.y) > 1e-12) {
        if (offset.y > 0) t = min(t, (bmax.y - p.y) / offset.y);
        else              t = min(t, (bmin.y - p.y) / offset.y);
    }
    // Z
    if (abs(offset.z) > 1e-12) {
        if (offset.z > 0) t = min(t, (bmax.z - p.z) / offset.z);
        else              t = min(t, (bmin.z - p.z) / offset.z);
    }
    t = clamp(t, 0.0, 1.0);
    return p + offset * t;
}

// 计算梯度（法线方向）- 基于论文中的方法
vector ComputeGradient(vector pos; vector voxel_size) {
    float test_val = volumesample(2, "density", pos);
    if (test_val == 0.0 && length(pos) > 1000000.0) {
        return set(0, 0, 1);
    }
    
    float eps = min(voxel_size.x, min(voxel_size.y, voxel_size.z)) * 0.5;
    
    float val_xp = volumesample(2, "density", pos + set(eps, 0, 0));
    float val_xn = volumesample(2, "density", pos - set(eps, 0, 0));
    float val_yp = volumesample(2, "density", pos + set(0, eps, 0));
    float val_yn = volumesample(2, "density", pos - set(0, eps, 0));
    float val_zp = volumesample(2, "density", pos + set(0, 0, eps));
    float val_zn = volumesample(2, "density", pos - set(0, 0, eps));
    
    vector grad;
    grad.x = (val_xp - val_xn) / (2.0 * eps);
    grad.y = (val_yp - val_yn) / (2.0 * eps);
    grad.z = (val_zp - val_zn) / (2.0 * eps);
    
    float len = length(grad);
    if (len > 0.00001) {
        return normalize(grad);
    }
    return set(0, 0, 1);
}

// 将偏移向量投影到切平面（垂直于法线的平面）
vector ProjectToTangentPlane(vector offset; vector normal) {
    float dot_product = dot(offset, normal);
    return offset - dot_product * normal;
}

// --- 主函数 ---
float isolevel = chf("isolevel");

// 只处理 boundary cell
int is_boundary_lowres = 0;
if (hasattrib(0, "point", "is_boundary_lowres")) {
    is_boundary_lowres = point(0, "is_boundary_lowres", @ptnum);
}

if (is_boundary_lowres != 1) {
    @group_del = 1;  // 标记删除非 boundary cell 点
    return;
}

// 读取边界方向
int boundary_axis = 2;  // 默认 Z 方向 (0=X, 1=Y, 2=Z)
if (hasattrib(0, "point", "boundary_axis")) {
    boundary_axis = point(0, "boundary_axis", @ptnum);
}

// 读取基础体素信息（与 transvoxelVEX.txt 一致）
vector base_voxel_size = point(0, "base_voxel_size", @ptnum);
vector min_bound = point(0, "min_bound", @ptnum);
int base_voxel_scale = point(0, "base_voxel_scale", @ptnum);
vector voxel_size = point(0, "voxel_size", @ptnum);
int voxel_scale = point(0, "voxel_scale", @ptnum);

// 读取体素索引
int x = point(0, "voxel_x", @ptnum);
int y = point(0, "voxel_y", @ptnum);
int z = point(0, "voxel_z", @ptnum);

// 补一圈标记：边/角 ring 往往缺少完整邻域，half-thickness 投影偏移可能把点推到 chunk 外
int is_makeup_ring = 0;
if (hasattrib(0, "point", "is_makeup_ring")) {
    is_makeup_ring = point(0, "is_makeup_ring", @ptnum);
}

// 从体素索引计算角点位置
vector origin;
if (hasattrib(0, "point", "chunk_origin")) {
    origin = point(0, "chunk_origin", @ptnum);
} else {
    origin = min_bound;
}

// 计算 chunk 边界（用于 clamp，避免补一圈导致三角面出界）
float chunk_size = 16.0;
if (hasattrib(0, "point", "chunk_size")) {
    chunk_size = point(0, "chunk_size", @ptnum);
} else {
    // fallback：使用 32*base_voxel_size 近似
    chunk_size = 32.0 * base_voxel_size.x;
}
vector chunk_min = origin;
vector chunk_max = origin + set(chunk_size, chunk_size, chunk_size);

// 实时计算8个角点的世界坐标位置并从 VDB 采样密度值
// 重要：这里与 formerVersion 的 pointsVEX + marchCubeVEX 语义对齐
// voxel_x/y/z 被当作 “upper corner”（右上前角）的网格坐标
// 8 个角点顺序与 pointsVEX.txt 的 boundary lowres cell 完全一致：
// [0] = (x-voxel_scale, y-voxel_scale, z-voxel_scale)
// [1] = (x,            y-voxel_scale, z-voxel_scale)
// [2] = (x-voxel_scale,y,             z-voxel_scale)
// [3] = (x,            y,             z-voxel_scale)
// [4] = (x-voxel_scale,y-voxel_scale, z)
// [5] = (x,            y-voxel_scale, z)
// [6] = (x-voxel_scale,y,             z)
// [7] = (x,            y,             z)
vector corner_pos[];
float corner_val[];
resize(corner_pos, 8);
resize(corner_val, 8);

corner_pos[0] = origin + set(x - voxel_scale, y - voxel_scale, z - voxel_scale) * base_voxel_size;
corner_pos[1] = origin + set(x,              y - voxel_scale, z - voxel_scale) * base_voxel_size;
corner_pos[2] = origin + set(x - voxel_scale, y,              z - voxel_scale) * base_voxel_size;
corner_pos[3] = origin + set(x,              y,              z - voxel_scale) * base_voxel_size;
corner_pos[4] = origin + set(x - voxel_scale, y - voxel_scale, z) * base_voxel_size;
corner_pos[5] = origin + set(x,              y - voxel_scale, z) * base_voxel_size;
corner_pos[6] = origin + set(x - voxel_scale, y,              z) * base_voxel_size;
corner_pos[7] = origin + set(x,              y,              z) * base_voxel_size;

for (int i = 0; i < 8; ++i) {
    corner_val[i] = volumesample(2, "density", corner_pos[i]);
}

// 计算 cube index
int cube_index = 0;
if (corner_val[0] <= isolevel) cube_index |= 1;
if (corner_val[1] <= isolevel) cube_index |= 2;
if (corner_val[2] <= isolevel) cube_index |= 4;
if (corner_val[3] <= isolevel) cube_index |= 8;
if (corner_val[4] <= isolevel) cube_index |= 16;
if (corner_val[5] <= isolevel) cube_index |= 32;
if (corner_val[6] <= isolevel) cube_index |= 64;
if (corner_val[7] <= isolevel) cube_index |= 128;

// 如果体素完全在内部或外部，则跳过
if (cube_index == 0 || cube_index == 255) {
    @group_del = 1;
    return;
}

// 使用 Marching Cubes 算法（与 marchCubeVEX.txt 一致）
// 检查 cube_index 是否在有效范围内（应该总是 0-255）
if (cube_index < 0 || cube_index > 255 || cube_index >= len(regularCellClass)) {
    @group_del = 1;
    return;
}

int cell_class = regularCellClass[cube_index];

// 内联获取顶点数和三角形数（VEX函数无法访问全局数组）
int baseIndex = cell_class * 16;

// 检查 baseIndex 是否在有效范围内
if (baseIndex < 0 || baseIndex >= len(regularCellData)) {
    @group_del = 1;
    return;
}

int geometryCounts = regularCellData[baseIndex];
int vertex_count = (geometryCounts / 16) & 0x0F;
int triangle_count = geometryCounts & 0x0F;

if (vertex_count == 0) {
    @group_del = 1;
    return;
}

// 计算边上的顶点位置
vector edge_vertices[];
resize(edge_vertices, vertex_count);

for (int i = 0; i < vertex_count; ++i) {
    int vertex_data_index = cube_index * 12 + i;
    
    if (vertex_data_index >= len(regularVertexData)) {
        break;
    }
    
    int vertex_data = regularVertexData[vertex_data_index];
    
    if (vertex_data == 0) break;
    
    int c1 = (vertex_data / 16) & 0x0F;
    int c2 = vertex_data & 0x0F;
    
    // 获取角点位置
    vector p1 = corner_pos[c1];
    vector p2 = corner_pos[c2];
    
    // 对特定角点进行半厚度偏移（根据边界方向）
    // 与 C++ computeTrianglesForTransvoxel 中的"normal cell half-thickness"一致
    // 需要沿 transvoxel 轴把特定面的角点抬高 voxelScale*0.5
    vector offset_direction;
    float offset_amount;
    
    // 确定哪些角点需要偏移（根据边界方向）
    int need_offset_c1 = 0;
    int need_offset_c2 = 0;
    
    if (boundary_axis == 0) {
        // X 方向边界：角点 0,2,4,6（左面，X 负方向）需要偏移
        offset_amount = voxel_scale * base_voxel_size.x * 0.5;
        offset_direction = set(offset_amount, 0, 0);
        if (c1 == 0 || c1 == 2 || c1 == 4 || c1 == 6) need_offset_c1 = 1;
        if (c2 == 0 || c2 == 2 || c2 == 4 || c2 == 6) need_offset_c2 = 1;
    } else if (boundary_axis == 1) {
        // Y 方向边界：角点 0,1,4,5（前面，Y 负方向）需要偏移
        offset_amount = voxel_scale * base_voxel_size.y * 0.5;
        offset_direction = set(0, offset_amount, 0);
        if (c1 == 0 || c1 == 1 || c1 == 4 || c1 == 5) need_offset_c1 = 1;
        if (c2 == 0 || c2 == 1 || c2 == 4 || c2 == 5) need_offset_c2 = 1;
    } else {
        // Z 方向边界（默认）：角点 0-3（底面，Z 负方向）需要偏移
        offset_amount = voxel_scale * base_voxel_size.z * 0.5;
        offset_direction = set(0, 0, offset_amount);
        if (c1 < 4) need_offset_c1 = 1;
        if (c2 < 4) need_offset_c2 = 1;
    }
    
    // 对需要偏移的角点进行切平面投影
    // 使用 base_voxel_size * voxel_scale 作为体素大小用于梯度计算
    vector cell_voxel_size = base_voxel_size * voxel_scale;
    // 补一圈 ring：仍然应用 half-thickness 偏移，但使用 ApplyOffsetClamped 限制在边界内
    if (need_offset_c1) {
        vector normal1 = ComputeGradient(p1, cell_voxel_size);
        vector projected_offset1 = ProjectToTangentPlane(offset_direction, normal1);
        // 不直接 clamp 点位，改为把 offset 按比例缩小到不越界，避免折叠/自相交
        // 对于 makeup ring，这确保偏移不会把点推到 chunk 外
        p1 = ApplyOffsetClamped(p1, projected_offset1, chunk_min, chunk_max);
    }
    if (need_offset_c2) {
        vector normal2 = ComputeGradient(p2, cell_voxel_size);
        vector projected_offset2 = ProjectToTangentPlane(offset_direction, normal2);
        p2 = ApplyOffsetClamped(p2, projected_offset2, chunk_min, chunk_max);
    }
    
    // 使用插值计算顶点位置
    vector vertex_pos = VertexLerp(isolevel, p1, p2, corner_val[c1], corner_val[c2]);
    edge_vertices[i] = vertex_pos;
}

// 根据cellData创建三角形
int cell_data_base = cell_class * 16 + 1;  // 跳过geometryCounts

// 检查 cell_data_base 是否在有效范围内
if (cell_data_base < 0 || cell_data_base >= len(regularCellData)) {
    @group_del = 1;
    return;
}

for (int i = 0; i < triangle_count * 3; i += 3) {
    int data_idx0 = cell_data_base + i;
    int data_idx1 = cell_data_base + i + 1;
    int data_idx2 = cell_data_base + i + 2;
    
    // 检查数组索引是否在有效范围内
    if (data_idx0 >= len(regularCellData) || data_idx1 >= len(regularCellData) || data_idx2 >= len(regularCellData)) {
        break;  // 超出数组范围，停止循环
    }
    
    int idx0 = regularCellData[data_idx0];
    int idx1 = regularCellData[data_idx1];
    int idx2 = regularCellData[data_idx2];
    
    if (idx0 < 0 || idx1 < 0 || idx2 < 0) break;
    
    if (idx0 >= len(edge_vertices) || idx1 >= len(edge_vertices) || idx2 >= len(edge_vertices)) {
        continue;
    }

    // 退化三角形保护：避免面积接近 0 导致的翻折/自相交伪影
    vector v0 = edge_vertices[idx0];
    vector v1 = edge_vertices[idx1];
    vector v2 = edge_vertices[idx2];
    vector n = cross(v1 - v0, v2 - v0);
    float area2 = length(n); // = 2*area
    if (area2 < 1e-8) {
        continue;
    }

    int p0_idx = addpoint(0, v0);
    int p1_idx = addpoint(0, v1);
    int p2_idx = addpoint(0, v2);
    int prim = addprim(0, "poly", p0_idx, p1_idx, p2_idx);
    
    // 设置为绿色以区分 boundary cell 生成的三角形
    setpointattrib(0, "Cd", p0_idx, set(0, 1, 0));
    setpointattrib(0, "Cd", p1_idx, set(0, 1, 0));
    setpointattrib(0, "Cd", p2_idx, set(0, 1, 0));
}

// 标记删除当前点阵点
@group_del = 1;

