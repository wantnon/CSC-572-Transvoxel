// VEX Code for Point Wrangle - Transvoxel 三角化
// Input 0: transition cell 点阵（来自 transCellVEX.txt）
// Input 1: 查找表数据（Detail Wrangle 节点，包含 transition cell 查找表）
// Input 2: fog VDB volume（用于实时采样密度值）
//
// 功能：
// 根据 transition cell 点阵生成三角面
// 每个 transition cell 点会被处理，生成相应的三角形网格

// 从 input1 读取查找表数据（detail 属性）
int transitionCellClass[];
int transitionCellData[];
int transitionVertexData[];

// 尝试从 input1 读取查找表
if (hasattrib(1, "detail", "transitionCellClass")) {
    transitionCellClass = detail(1, "transitionCellClass");
    transitionCellData = detail(1, "transitionCellData");
    transitionVertexData = detail(1, "transitionVertexData");
} else {
    // 查找表不存在，尝试从 input0 读取（向后兼容）
    if (hasattrib(0, "detail", "transitionCellClass")) {
        transitionCellClass = detail(0, "transitionCellClass");
        transitionCellData = detail(0, "transitionCellData");
        transitionVertexData = detail(0, "transitionVertexData");
    }
}

// 检查查找表是否存在
if (len(transitionCellClass) < 512 || len(transitionCellData) < 2072 || len(transitionVertexData) < 6144) {
    @group_del = 1;  // 标记删除，查找表数据不完整
    return;
}

// 线性插值计算交点（与 computeTrianglesForTransvoxel 中的插值方式完全一致）
vector VertexLerp(float isolevel; vector p1, p2; float val1, val2) {
    if (abs(isolevel - val1) < 0.00001) return p1;
    if (abs(isolevel - val2) < 0.00001) return p2;
    if (abs(val1 - val2) < 0.00001) return p1;

    float t;
    if (abs(isolevel) < 0.00001) {
        t = val2 / (val2 - val1);
        return p1 * t + p2 * (1.0 - t);
    } else {
        t = (isolevel - val1) / (val2 - val1);
        return lerp(p1, p2, t);
    }
}

// 计算梯度（法线方向）- 基于论文中的方法
vector ComputeGradient(vector pos; vector voxel_size) {
    float test_val = volumesample(2, "density", pos);
    if (test_val == 0.0 && length(pos) > 1000000.0) {
        return set(0, 0, 1);
    }
    
    float eps = min(voxel_size.x, min(voxel_size.y, voxel_size.z)) * 0.5;
    
    float val_xp = volumesample(2, "density", pos + set(eps, 0, 0));
    float val_xn = volumesample(2, "density", pos - set(eps, 0, 0));
    float val_yp = volumesample(2, "density", pos + set(0, eps, 0));
    float val_yn = volumesample(2, "density", pos - set(0, eps, 0));
    float val_zp = volumesample(2, "density", pos + set(0, 0, eps));
    float val_zn = volumesample(2, "density", pos - set(0, 0, eps));
    
    vector grad;
    grad.x = (val_xp - val_xn) / (2.0 * eps);
    grad.y = (val_yp - val_yn) / (2.0 * eps);
    grad.z = (val_zp - val_zn) / (2.0 * eps);
    
    float len = length(grad);
    if (len > 0.00001) {
        return normalize(grad);
    }
    return set(0, 0, 1);
}

// 将偏移向量投影到切平面
vector ProjectToTangentPlane(vector offset; vector normal) {
    float dot_product = dot(offset, normal);
    return offset - dot_product * normal;
}

// 将"偏移"限制在 AABB 内：不直接 clamp 点位（会造成折叠/自相交），而是按比例缩小 offset
vector ApplyOffsetClamped(vector p; vector offset; vector bmin; vector bmax) {
    float t = 1.0;
    // X
    if (abs(offset.x) > 1e-12) {
        if (offset.x > 0) t = min(t, (bmax.x - p.x) / offset.x);
        else              t = min(t, (bmin.x - p.x) / offset.x);
    }
    // Y
    if (abs(offset.y) > 1e-12) {
        if (offset.y > 0) t = min(t, (bmax.y - p.y) / offset.y);
        else              t = min(t, (bmin.y - p.y) / offset.y);
    }
    // Z
    if (abs(offset.z) > 1e-12) {
        if (offset.z > 0) t = min(t, (bmax.z - p.z) / offset.z);
        else              t = min(t, (bmin.z - p.z) / offset.z);
    }
    t = clamp(t, 0.0, 1.0);
    return p + offset * t;
}

// --- 主函数 ---
float isolevel = chf("isolevel");

// 只处理 transition cell 点
int is_transition = 0;
if (hasattrib(0, "point", "is_transition")) {
    is_transition = point(0, "is_transition", @ptnum);
}

if (is_transition != 1) {
    @group_del = 1;  // 标记删除非 transition cell 点
    return;
}

// 读取基础体素信息
vector base_voxel_size = point(0, "base_voxel_size", @ptnum);
vector min_bound = point(0, "min_bound", @ptnum);
int base_voxel_scale = point(0, "base_voxel_scale", @ptnum);
vector voxel_size = point(0, "voxel_size", @ptnum);
int voxel_scale = point(0, "voxel_scale", @ptnum);

// 读取 LOD 信息
int lod_scale_0 = point(0, "lod_scale_0", @ptnum);
int lod_scale_1 = point(0, "lod_scale_1", @ptnum);

// 读取当前点的体素信息
int x = point(0, "voxel_x", @ptnum);
int y = point(0, "voxel_y", @ptnum);
int z = point(0, "voxel_z", @ptnum);

// 读取边界方向（0=X, 1=Y, 2=Z，默认 Z）
int boundary_axis = 2;
if (hasattrib(0, "point", "boundary_axis")) {
    boundary_axis = point(0, "boundary_axis", @ptnum);
}

// 穷举法的绕序 case 标识（更可靠，避免符号计算的歧义）
// 0: X轴负方向, 1: X轴正方向, 2: Y轴负方向, 3: Y轴正方向, 4: Z轴负方向, 5: Z轴正方向
// C++ 版本的查找表默认是 case 4 (Z轴负方向，axis=NegativeZ)
int winding_case = 4;  // 默认 Z轴负方向（与 C++ 约定一致）
if (hasattrib(0, "point", "winding_case")) {
    winding_case = point(0, "winding_case", @ptnum);
}

// 兼容性保留（但主要用 winding_case）
int boundary_sign = -1;
if (hasattrib(0, "point", "boundary_sign")) {
    boundary_sign = point(0, "boundary_sign", @ptnum);
}

// 补一圈标记：边/角 ring 往往缺少完整邻域，half-thickness 投影偏移可能把点推到 chunk 外
int is_makeup_ring = 0;
if (hasattrib(0, "point", "is_makeup_ring")) {
    is_makeup_ring = point(0, "is_makeup_ring", @ptnum);
}

// 计算 chunk 边界（用于 clamp，避免补一圈导致三角面出界）
vector origin;
if (hasattrib(0, "point", "chunk_origin")) {
    origin = point(0, "chunk_origin", @ptnum);
} else {
    origin = min_bound;
}

float chunk_size = 16.0;
int voxel_res_attr = 32;
if (hasattrib(0, "point", "chunk_size")) {
    chunk_size = point(0, "chunk_size", @ptnum);
}
if (hasattrib(0, "point", "voxel_res")) {
    voxel_res_attr = point(0, "voxel_res", @ptnum);
}
vector chunk_min = origin;
vector chunk_max = origin + set(chunk_size, chunk_size, chunk_size);

// 按照 MarchingCubesCS.usf 的方式：从体素索引实时计算角点位置和采样密度值
vector trans_corner_pos[];
float trans_corner_val[];
resize(trans_corner_pos, 13);
resize(trans_corner_val, 13);

// 根据边界方向计算高分辨率面的坐标
int coord_high;  // 高分辨率面的坐标（在边界轴上的值）
if (boundary_axis == 0) {
    // X 方向边界：高分辨率面在 x - voxel_scale
    coord_high = x - voxel_scale;
} else if (boundary_axis == 1) {
    // Y 方向边界：高分辨率面在 y - voxel_scale
    coord_high = y - voxel_scale;
} else {
    // Z 方向边界（默认）：高分辨率面在 z - voxel_scale
    coord_high = z - voxel_scale;
}

// 角点 0-8: 高分辨率面的 3x3 网格
// 根据边界方向调整角点计算
if (boundary_axis == 0) {
    // X 方向边界：固定 x = coord_high，在 Y-Z 平面上生成 3x3 网格
    vector pos0_grid = set(coord_high, y - voxel_scale, z - voxel_scale);
    trans_corner_pos[0] = min_bound + pos0_grid * base_voxel_size;
    trans_corner_val[0] = volumesample(2, "density", trans_corner_pos[0]);
    
    vector pos1_grid = set(coord_high, y - voxel_scale/2, z - voxel_scale);
    trans_corner_pos[1] = min_bound + pos1_grid * base_voxel_size;
    trans_corner_val[1] = volumesample(2, "density", trans_corner_pos[1]);
    
    vector pos2_grid = set(coord_high, y, z - voxel_scale);
    trans_corner_pos[2] = min_bound + pos2_grid * base_voxel_size;
    trans_corner_val[2] = volumesample(2, "density", trans_corner_pos[2]);
    
    vector pos3_grid = set(coord_high, y - voxel_scale, z - voxel_scale/2);
    trans_corner_pos[3] = min_bound + pos3_grid * base_voxel_size;
    trans_corner_val[3] = volumesample(2, "density", trans_corner_pos[3]);
    
    vector pos4_grid = set(coord_high, y - voxel_scale/2, z - voxel_scale/2);
    trans_corner_pos[4] = min_bound + pos4_grid * base_voxel_size;
    trans_corner_val[4] = volumesample(2, "density", trans_corner_pos[4]);
    
    vector pos5_grid = set(coord_high, y, z - voxel_scale/2);
    trans_corner_pos[5] = min_bound + pos5_grid * base_voxel_size;
    trans_corner_val[5] = volumesample(2, "density", trans_corner_pos[5]);
    
    vector pos6_grid = set(coord_high, y - voxel_scale, z);
    trans_corner_pos[6] = min_bound + pos6_grid * base_voxel_size;
    trans_corner_val[6] = volumesample(2, "density", trans_corner_pos[6]);
    
    vector pos7_grid = set(coord_high, y - voxel_scale/2, z);
    trans_corner_pos[7] = min_bound + pos7_grid * base_voxel_size;
    trans_corner_val[7] = volumesample(2, "density", trans_corner_pos[7]);
    
    vector pos8_grid = set(coord_high, y, z);
    trans_corner_pos[8] = min_bound + pos8_grid * base_voxel_size;
    trans_corner_val[8] = volumesample(2, "density", trans_corner_pos[8]);
} else if (boundary_axis == 1) {
    // Y 方向边界：固定 y = coord_high，在 X-Z 平面上生成 3x3 网格
    vector pos0_grid = set(x - voxel_scale, coord_high, z - voxel_scale);
    trans_corner_pos[0] = min_bound + pos0_grid * base_voxel_size;
    trans_corner_val[0] = volumesample(2, "density", trans_corner_pos[0]);
    
    vector pos1_grid = set(x - voxel_scale/2, coord_high, z - voxel_scale);
    trans_corner_pos[1] = min_bound + pos1_grid * base_voxel_size;
    trans_corner_val[1] = volumesample(2, "density", trans_corner_pos[1]);
    
    vector pos2_grid = set(x, coord_high, z - voxel_scale);
    trans_corner_pos[2] = min_bound + pos2_grid * base_voxel_size;
    trans_corner_val[2] = volumesample(2, "density", trans_corner_pos[2]);
    
    vector pos3_grid = set(x - voxel_scale, coord_high, z - voxel_scale/2);
    trans_corner_pos[3] = min_bound + pos3_grid * base_voxel_size;
    trans_corner_val[3] = volumesample(2, "density", trans_corner_pos[3]);
    
    vector pos4_grid = set(x - voxel_scale/2, coord_high, z - voxel_scale/2);
    trans_corner_pos[4] = min_bound + pos4_grid * base_voxel_size;
    trans_corner_val[4] = volumesample(2, "density", trans_corner_pos[4]);
    
    vector pos5_grid = set(x, coord_high, z - voxel_scale/2);
    trans_corner_pos[5] = min_bound + pos5_grid * base_voxel_size;
    trans_corner_val[5] = volumesample(2, "density", trans_corner_pos[5]);
    
    vector pos6_grid = set(x - voxel_scale, coord_high, z);
    trans_corner_pos[6] = min_bound + pos6_grid * base_voxel_size;
    trans_corner_val[6] = volumesample(2, "density", trans_corner_pos[6]);
    
    vector pos7_grid = set(x - voxel_scale/2, coord_high, z);
    trans_corner_pos[7] = min_bound + pos7_grid * base_voxel_size;
    trans_corner_val[7] = volumesample(2, "density", trans_corner_pos[7]);
    
    vector pos8_grid = set(x, coord_high, z);
    trans_corner_pos[8] = min_bound + pos8_grid * base_voxel_size;
    trans_corner_val[8] = volumesample(2, "density", trans_corner_pos[8]);
} else {
    // Z 方向边界（默认）：固定 z = coord_high，在 X-Y 平面上生成 3x3 网格
    vector pos0_grid = set(x - voxel_scale, y - voxel_scale, coord_high);
    trans_corner_pos[0] = min_bound + pos0_grid * base_voxel_size;
    trans_corner_val[0] = volumesample(2, "density", trans_corner_pos[0]);
    
    vector pos1_grid = set(x - voxel_scale/2, y - voxel_scale, coord_high);
    trans_corner_pos[1] = min_bound + pos1_grid * base_voxel_size;
    trans_corner_val[1] = volumesample(2, "density", trans_corner_pos[1]);
    
    vector pos2_grid = set(x, y - voxel_scale, coord_high);
    trans_corner_pos[2] = min_bound + pos2_grid * base_voxel_size;
    trans_corner_val[2] = volumesample(2, "density", trans_corner_pos[2]);
    
    vector pos3_grid = set(x - voxel_scale, y - voxel_scale/2, coord_high);
    trans_corner_pos[3] = min_bound + pos3_grid * base_voxel_size;
    trans_corner_val[3] = volumesample(2, "density", trans_corner_pos[3]);
    
    vector pos4_grid = set(x - voxel_scale/2, y - voxel_scale/2, coord_high);
    trans_corner_pos[4] = min_bound + pos4_grid * base_voxel_size;
    trans_corner_val[4] = volumesample(2, "density", trans_corner_pos[4]);
    
    vector pos5_grid = set(x, y - voxel_scale/2, coord_high);
    trans_corner_pos[5] = min_bound + pos5_grid * base_voxel_size;
    trans_corner_val[5] = volumesample(2, "density", trans_corner_pos[5]);
    
    vector pos6_grid = set(x - voxel_scale, y, coord_high);
    trans_corner_pos[6] = min_bound + pos6_grid * base_voxel_size;
    trans_corner_val[6] = volumesample(2, "density", trans_corner_pos[6]);
    
    vector pos7_grid = set(x - voxel_scale/2, y, coord_high);
    trans_corner_pos[7] = min_bound + pos7_grid * base_voxel_size;
    trans_corner_val[7] = volumesample(2, "density", trans_corner_pos[7]);
    
    vector pos8_grid = set(x, y, coord_high);
    trans_corner_pos[8] = min_bound + pos8_grid * base_voxel_size;
    trans_corner_val[8] = volumesample(2, "density", trans_corner_pos[8]);
}

// 角点 9-12：低分辨率面的 4 个角点（初始与高分辨率面的某些角点相同）
trans_corner_pos[9] = trans_corner_pos[0];
trans_corner_val[9] = trans_corner_val[0];
trans_corner_pos[10] = trans_corner_pos[2];
trans_corner_val[10] = trans_corner_val[2];
trans_corner_pos[11] = trans_corner_pos[6];
trans_corner_val[11] = trans_corner_val[6];
trans_corner_pos[12] = trans_corner_pos[8];
trans_corner_val[12] = trans_corner_val[8];

// 补一圈处理：如果角点位置超出 chunk 边界，将其 clamp 到边界内
// 这确保补充的一圈 transition cell 与 boundary cell 能正确衔接
if (is_makeup_ring == 1) {
    for (int i = 0; i < 13; i++) {
        trans_corner_pos[i] = clamp(trans_corner_pos[i], chunk_min, chunk_max);
    }
}

// 计算 transition cube index（使用 9 个角点）
int transCubeIndex = 0;
if (trans_corner_val[0] <= isolevel) transCubeIndex |= 1;
if (trans_corner_val[1] <= isolevel) transCubeIndex |= 2;
if (trans_corner_val[2] <= isolevel) transCubeIndex |= 4;
if (trans_corner_val[3] <= isolevel) transCubeIndex |= 128;
if (trans_corner_val[4] <= isolevel) transCubeIndex |= 256;
if (trans_corner_val[5] <= isolevel) transCubeIndex |= 8;
if (trans_corner_val[6] <= isolevel) transCubeIndex |= 64;
if (trans_corner_val[7] <= isolevel) transCubeIndex |= 32;
if (trans_corner_val[8] <= isolevel) transCubeIndex |= 16;

// 如果体素完全在内部或外部，则跳过
if (transCubeIndex == 0 || transCubeIndex == 511) {
    @group_del = 1;  // 标记删除不需要的点
    return;
}

// 使用 Transition Cell 算法
int transClassRaw = transitionCellClass[transCubeIndex];
int transCellClass = transClassRaw & 0x7F;
int transInvertWinding = (transClassRaw & 0x80) != 0;

if (transCellClass < 0 || transCellClass >= 56) {
    @group_del = 1;
    return;
}

// 获取该类的三角化数据
int baseIndex = transCellClass * 37;
if (baseIndex < 0 || baseIndex + 36 >= len(transitionCellData)) {
    @group_del = 1;
    return;
}
int geometryCounts = transitionCellData[baseIndex];
int vertex_count = (geometryCounts / 16) & 0x0F;
int triangle_count = geometryCounts & 0x0F;

if (vertex_count == 0) {
    @group_del = 1;
    return;
}

// 获取该情况的顶点数据
vector edge_vertices[];
resize(edge_vertices, vertex_count);

// 根据边界方向确定轴和偏移方向
int axis;  // 32=Negative Z, 16=Positive Z, 8=Negative Y, 4=Positive Y, 2=Negative X, 1=Positive X
vector offset_direction;
float offset_amount;

if (boundary_axis == 0) {
    // X 方向边界：偏移沿 X 轴
    // 轴方向取决于高分辨率在正/负方向
    axis = (boundary_sign > 0) ? 1 : 2;
    offset_amount = voxel_scale * base_voxel_size.x * 0.5;
    // 规范：偏移方向取“从高分辨率面指向低分辨率面”的方向（与 C++ 里 axis=NegativeZ 时做 +Z 偏移一致）
    offset_direction = set(-boundary_sign * offset_amount, 0, 0);
} else if (boundary_axis == 1) {
    // Y 方向边界：偏移沿 Y 轴
    axis = (boundary_sign > 0) ? 4 : 8;
    offset_amount = voxel_scale * base_voxel_size.y * 0.5;
    offset_direction = set(0, -boundary_sign * offset_amount, 0);
} else {
    // Z 方向边界（默认）：偏移沿 Z 轴
    axis = (boundary_sign > 0) ? 16 : 32;
    offset_amount = voxel_scale * base_voxel_size.z * 0.5;
    offset_direction = set(0, 0, -boundary_sign * offset_amount);
}

int actual_vertex_count = 0;

for (int i = 0; i < vertex_count; ++i) {
    int vertex_data_index = transCubeIndex * 12 + i;
    
    if (vertex_data_index >= len(transitionVertexData)) break;
    
    int vertex_data = transitionVertexData[vertex_data_index];
    
    if (vertex_data == 0) break;
    
    int c1 = (vertex_data / 16) & 0x0F;
    int c2 = vertex_data & 0x0F;
    
    if (c1 >= 13 || c2 >= 13) {
        continue;
    }
    
    // 获取角点位置和密度值
    vector cornerPos1 = trans_corner_pos[c1];
    vector cornerPos2 = trans_corner_pos[c2];
    float isovalue1 = trans_corner_val[c1];
    float isovalue2 = trans_corner_val[c2];
    
    // half-thickness：对低分辨率面的角点（corner >= 9）做轴向偏移
    // 补一圈 ring：仍然应用 half-thickness 偏移，但使用 ApplyOffsetClamped 限制在边界内
    if (c1 >= 9) {
        vector normal1 = ComputeGradient(cornerPos1, base_voxel_size);
        vector projected_offset1 = ProjectToTangentPlane(offset_direction, normal1);
        // 不直接 clamp 点位，改为把 offset 按比例缩小到不越界，避免折叠/自相交
        // 对于 makeup ring，这确保偏移不会把点推到 chunk 外
        cornerPos1 = ApplyOffsetClamped(cornerPos1, projected_offset1, chunk_min, chunk_max);
    }
    if (c2 >= 9) {
        vector normal2 = ComputeGradient(cornerPos2, base_voxel_size);
        vector projected_offset2 = ProjectToTangentPlane(offset_direction, normal2);
        cornerPos2 = ApplyOffsetClamped(cornerPos2, projected_offset2, chunk_min, chunk_max);
    }
    
    // 使用插值计算顶点位置
    vector vertex_pos = VertexLerp(isolevel, cornerPos1, cornerPos2, isovalue1, isovalue2);
    edge_vertices[actual_vertex_count] = vertex_pos;
    actual_vertex_count++;
}

// 根据 cellData 创建三角形
int cell_data_base = transCellClass * 37 + 1;
for (int i = 0; i < triangle_count * 3; i += 3) {
    int idx0 = transitionCellData[cell_data_base + i];
    int idx1 = transitionCellData[cell_data_base + i + 1];
    int idx2 = transitionCellData[cell_data_base + i + 2];
    
    if (idx0 < 0 || idx1 < 0 || idx2 < 0) break;
    
    if (idx0 >= actual_vertex_count || idx1 >= actual_vertex_count || idx2 >= actual_vertex_count) {
        continue;
    }
    
    // 穷举法的绕序修正（更可靠，避免符号歧义）：
    // - transInvertWinding：来自查找表（case 自身需要翻转）
    // - winding_case：精确标识边界方向和位置关系
    int flip_winding = transInvertWinding;
    
    // 穷举表：基于实际测试结果决定每种 case 是否需要额外翻转
    // 0: X轴负, 1: X轴正, 2: Y轴负, 3: Y轴正, 4: Z轴负(默认), 5: Z轴正
    // 查找表基于 case 4 (Z轴负方向)，尝试反向逻辑：只有 case 4 不额外翻转，其他都翻转
    if (winding_case != 4) {
        // 除了默认的 Z轴负方向，其他所有 case 都需要额外翻转
        flip_winding = !flip_winding;
    }
    
    if (flip_winding) {
        int tmp = idx1;
        idx1 = idx2;
        idx2 = tmp;
    }
    
    int p0_idx = addpoint(0, edge_vertices[idx0]);
    int p1_idx = addpoint(0, edge_vertices[idx1]);
    int p2_idx = addpoint(0, edge_vertices[idx2]);
    int prim = addprim(0, "poly", p0_idx, p1_idx, p2_idx);
    
    // 在顶点属性上设置为红色
    setpointattrib(0, "Cd", p0_idx, set(1, 0, 0));
    setpointattrib(0, "Cd", p1_idx, set(1, 0, 0));
    setpointattrib(0, "Cd", p2_idx, set(1, 0, 0));
}

// 标记删除当前点阵点（三角形已生成，不再需要原始点）
@group_del = 1;

