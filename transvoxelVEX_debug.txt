// VEX Code for Point Wrangle - Transvoxel 接缝修补（调试版本）
// 从 input1 读取 Transition Cell 查找表数据
// Input 0: 体素点云（来自 pointsVEX.txt，包含 transition cell 点）
// Input 1: 查找表数据（Detail Wrangle 节点，包含 transition cell 查找表）

// 从 input1 读取查找表数据（detail 属性）
int transitionCellClass[] = detail(1, "transitionCellClass");
int transitionCellData[] = detail(1, "transitionCellData");
int transitionVertexData[] = detail(1, "transitionVertexData");

// 调试：检查查找表是否加载
if (@ptnum == 0) {
    printf("Debug: transitionCellClass length = %d\n", len(transitionCellClass));
    printf("Debug: transitionCellData length = %d\n", len(transitionCellData));
    printf("Debug: transitionVertexData length = %d\n", len(transitionVertexData));
}

// 线性插值计算交点（与 computeTrianglesForTransvoxel 中的插值方式完全一致）
vector VertexLerp(float isolevel; vector p1, p2; float val1, val2) {
    if (abs(isolevel - val1) < 0.00001) return p1;
    if (abs(isolevel - val2) < 0.00001) return p2;
    if (abs(val1 - val2) < 0.00001) return p1;

    float t;
    if (abs(isolevel) < 0.00001) {
        t = val2 / (val2 - val1);
        return p1 * t + p2 * (1.0 - t);
    } else {
        t = (isolevel - val1) / (val2 - val1);
        return lerp(p1, p2, t);
    }
}

// --- 主函数 ---
float isolevel = chf("isolevel"); // 从通道获取isolevel

// 只处理 transition cell 点
int is_transition = point(0, "is_transition", @ptnum);
if (is_transition != 1) {
    @group_del = 1;  // 标记删除非 transition cell 点
    return;
}

// 调试：输出 transition cell 点信息
if (@ptnum < 5) {
    printf("Point %d: is_transition = %d\n", @ptnum, is_transition);
}

vector voxel_size = point(0, "voxel_size", @ptnum);
vector min_bound = point(0, "min_bound", @ptnum);
int voxel_scale = point(0, "voxel_scale", @ptnum);

// 读取当前点的体素信息
int x = point(0, "voxel_x", @ptnum);
int y = point(0, "voxel_y", @ptnum);
int z = point(0, "voxel_z", @ptnum);

// 从点属性读取 transition cell 的 13 个角点位置和密度值
vector trans_corner_pos[] = point(0, "trans_corner_pos", @ptnum);
float trans_corner_val[] = point(0, "trans_corner_val", @ptnum);

// 检查数组是否有效
if (len(trans_corner_pos) < 13 || len(trans_corner_val) < 13) {
    if (@ptnum < 5) {
        printf("Point %d: Invalid corner arrays! pos_len=%d, val_len=%d\n", 
               @ptnum, len(trans_corner_pos), len(trans_corner_val));
    }
    @group_del = 1;  // 标记删除无效点
    return;
}

// 计算 transition cube index（使用 9 个角点，不是 8 个）
// 根据 C++ 代码：只使用前 9 个角点（高分辨率面）来计算 cube index
int transCubeIndex = 0;
if (trans_corner_val[0] <= isolevel) transCubeIndex |= 1;
if (trans_corner_val[1] <= isolevel) transCubeIndex |= 2;
if (trans_corner_val[2] <= isolevel) transCubeIndex |= 4;
if (trans_corner_val[3] <= isolevel) transCubeIndex |= 128;
if (trans_corner_val[4] <= isolevel) transCubeIndex |= 256;
if (trans_corner_val[5] <= isolevel) transCubeIndex |= 8;
if (trans_corner_val[6] <= isolevel) transCubeIndex |= 64;
if (trans_corner_val[7] <= isolevel) transCubeIndex |= 32;
if (trans_corner_val[8] <= isolevel) transCubeIndex |= 16;

// 调试：输出 cube index
if (@ptnum < 5) {
    printf("Point %d: transCubeIndex = %d\n", @ptnum, transCubeIndex);
}

// 如果体素完全在内部或外部，则跳过
if (transCubeIndex == 0 || transCubeIndex == 511) {
    if (@ptnum < 5) {
        printf("Point %d: Skipped (cubeIndex = %d, all inside/outside)\n", @ptnum, transCubeIndex);
    }
    @group_del = 1;  // 标记删除不需要的点
    return;
}

// 检查查找表数组边界
if (transCubeIndex >= len(transitionCellClass)) {
    printf("Point %d: ERROR! transCubeIndex %d >= transitionCellClass length %d\n", 
           @ptnum, transCubeIndex, len(transitionCellClass));
    @group_del = 1;
    return;
}

// 使用 Transition Cell 算法
// transitionCellClass 数组元素的高位可能包含其他信息，低 7 位是 class index
int transCellClass = transitionCellClass[transCubeIndex] & 0x7F;  // 低 7 位是 class index

// 调试：输出 cell class
if (@ptnum < 5) {
    printf("Point %d: transCellClass = %d\n", @ptnum, transCellClass);
}

// 获取该类的三角化数据
// transitionCellData 格式与 regularCellData 相同：geometryCounts, 然后是顶点索引数组
int baseIndex = transCellClass * 16;
if (baseIndex >= len(transitionCellData)) {
    printf("Point %d: ERROR! baseIndex %d >= transitionCellData length %d\n", 
           @ptnum, baseIndex, len(transitionCellData));
    @group_del = 1;
    return;
}

int geometryCounts = transitionCellData[baseIndex];
int vertex_count = (geometryCounts / 16) & 0x0F;  // 顶点数（高4位，右移4位 = 除以16）
int triangle_count = geometryCounts & 0x0F;       // 三角形数（低4位）

// 调试：输出几何计数
if (@ptnum < 5) {
    printf("Point %d: vertex_count = %d, triangle_count = %d\n", @ptnum, vertex_count, triangle_count);
}

if (vertex_count == 0) {
    if (@ptnum < 5) {
        printf("Point %d: Skipped (vertex_count = 0)\n", @ptnum);
    }
    @group_del = 1;  // 标记删除没有顶点的点
    return;
}

// 获取该情况的顶点数据（从 transitionVertexData 中读取）
// transitionVertexData 数组索引: transCubeIndex * 12 + vertex_index
vector edge_vertices[];
resize(edge_vertices, vertex_count);

// 轴方向：Negative z axis (1 << 5 = 32)
int axis = 32;  // 1 << 5 = 32

int actual_vertex_count = 0;
for (int i = 0; i < vertex_count; ++i) {
    // 从 transitionVertexData 数组获取顶点数据
    int vertex_data_index = transCubeIndex * 12 + i;
    
    if (vertex_data_index >= len(transitionVertexData)) {
        printf("Point %d: ERROR! vertex_data_index %d >= transitionVertexData length %d\n", 
               @ptnum, vertex_data_index, len(transitionVertexData));
        break;
    }
    
    int vertex_data = transitionVertexData[vertex_data_index];
    
    if (vertex_data == 0) break;  // 没有更多顶点
    
    // 提取角点索引（与 C++ 代码一致：corner1 = (vertex >> 4) & 0x000F; corner2 = vertex & 0x000F）
    // VEX 不支持 >> 操作符，使用 / 16 代替（右移4位 = 除以16）
    int c1 = (vertex_data / 16) & 0x0F;  // 高4位 = corner1
    int c2 = vertex_data & 0x0F;         // 低4位 = corner2
    
    // 检查角点索引有效性
    if (c1 >= 13 || c2 >= 13) {
        printf("Point %d: ERROR! Invalid corner indices: c1=%d, c2=%d\n", @ptnum, c1, c2);
        break;
    }
    
    // 获取角点位置和密度值
    vector cornerPos1 = trans_corner_pos[c1];
    vector cornerPos2 = trans_corner_pos[c2];
    float isovalue1 = trans_corner_val[c1];
    float isovalue2 = trans_corner_val[c2];
    
    // LOD Smoothing（与 C++ 代码一致）
    // 注意：VEX 中简化处理，主要关注 corner >= 9 的情况
    int lod = voxel_scale;
    while (lod > 1) {
        vector centerVoxelPosition = (cornerPos1 + cornerPos2) * 0.5;
        // 在 VEX 中，我们需要从 volume 重新采样中心点
        // 这里简化处理，直接使用插值
        float centerIso = volumesample(0, "density", centerVoxelPosition);
        
        if (centerIso <= 0) {
            if (isovalue1 <= 0) {
                if (c1 < 9) {  // Corner is on high-res face && LOD > 2
                    if (lod > 2) {
                        isovalue1 = centerIso;
                        cornerPos1 = centerVoxelPosition;
                    }
                } else {  // Else it's ok for LOD to be 2
                    isovalue1 = centerIso;
                    cornerPos1 = centerVoxelPosition;
                }
            } else {
                if (c2 < 9) {  // Corner is on high-res face && LOD > 2
                    if (lod > 2) {
                        isovalue2 = centerIso;
                        cornerPos2 = centerVoxelPosition;
                    }
                } else {  // Else it's ok for LOD to be 2
                    isovalue2 = centerIso;
                    cornerPos2 = centerVoxelPosition;
                }
            }
        } else {
            if (isovalue1 > 0) {
                if (c1 < 9) {  // Corner is on high-res face && LOD > 2
                    if (lod > 2) {
                        isovalue1 = centerIso;
                        cornerPos1 = centerVoxelPosition;
                    }
                } else {  // Else it's ok for LOD to be 2
                    isovalue1 = centerIso;
                    cornerPos1 = centerVoxelPosition;
                }
            } else {
                if (c2 < 9) {  // Corner is on high-res face && LOD > 2
                    if (lod > 2) {
                        isovalue2 = centerIso;
                        cornerPos2 = centerVoxelPosition;
                    }
                } else {  // Else it's ok for LOD to be 2
                    isovalue2 = centerIso;
                    cornerPos2 = centerVoxelPosition;
                }
            }
        }
        lod /= 2;
    }
    
    // Scale the normal cell to be half the volume size along the transvoxel axes
    // 与 C++ 代码一致：对于 Negative z axis，corner >= 9 的角点需要调整 Z 坐标
    // C++: cornerPos1.z += voxelScale * 0.5f;
    // VEX: 需要将 voxelScale（整数）转换为世界坐标单位
    if (axis == 32) {  // Negative z axis (1 << 5 = 32)
        if (c1 >= 9) {
            // C++ 中 voxelScale 是整数，表示体素网格单位
            // VEX 中需要转换为世界坐标：voxel_scale * voxel_size.z * 0.5
            cornerPos1.z += voxel_scale * voxel_size.z * 0.5;
        }
        if (c2 >= 9) {
            cornerPos2.z += voxel_scale * voxel_size.z * 0.5;
        }
    }
    
    // 使用与 computeTrianglesForTransvoxel 相同的插值公式
    vector vertex_pos = VertexLerp(isolevel, cornerPos1, cornerPos2, isovalue1, isovalue2);
    edge_vertices[actual_vertex_count] = vertex_pos;
    actual_vertex_count++;
}

// 调试：输出实际顶点数
if (@ptnum < 5) {
    printf("Point %d: actual_vertex_count = %d\n", @ptnum, actual_vertex_count);
}

// 根据 cellData 创建三角形
int cell_data_base = transCellClass * 16 + 1;  // 跳过 geometryCounts
int triangles_created = 0;
for (int i = 0; i < triangle_count * 3; i += 3) {
    int data_index = cell_data_base + i;
    if (data_index + 2 >= len(transitionCellData)) {
        printf("Point %d: ERROR! data_index %d >= transitionCellData length %d\n", 
               @ptnum, data_index, len(transitionCellData));
        break;
    }
    
    int idx0 = transitionCellData[cell_data_base + i];
    int idx1 = transitionCellData[cell_data_base + i + 1];
    int idx2 = transitionCellData[cell_data_base + i + 2];
    
    if (idx0 < 0 || idx1 < 0 || idx2 < 0) break;
    
    if (idx0 >= actual_vertex_count || idx1 >= actual_vertex_count || idx2 >= actual_vertex_count) {
        if (@ptnum < 5) {
            printf("Point %d: Vertex index out of range: idx0=%d, idx1=%d, idx2=%d, max=%d\n", 
                   @ptnum, idx0, idx1, idx2, actual_vertex_count);
        }
        continue;  // 索引越界，跳过
    }
    
    int p0_idx = addpoint(0, edge_vertices[idx0]);
    int p1_idx = addpoint(0, edge_vertices[idx1]);
    int p2_idx = addpoint(0, edge_vertices[idx2]);
    addprim(0, "poly", p0_idx, p1_idx, p2_idx);
    triangles_created++;
}

// 调试：输出创建的三角形数
if (@ptnum < 5) {
    printf("Point %d: Created %d triangles\n", @ptnum, triangles_created);
}

// 标记删除当前点阵点（三角形已生成，不再需要原始点）
@group_del = 1;

